local lsp, api, fn, uv = vim.lsp, vim.api, vim.fn, vim.uv
local rename_feature = lsp.protocol.Methods.textDocument_rename
local prepare_rename_feature = lsp.protocol.Methods.textDocument_prepareRename

local config = require("LspUI.config")
local lib_notify = require("LspUI.lib.notify")
local lib_util = require("LspUI.lib.util")
local lib_windows = require("LspUI.lib.windows")

--- @alias LspUI_prepare_rename_res lsp.Range | { range: lsp.Range, placeholder: string } | { defaultBehavior: boolean } | nil

-- TODO: add progress support !!
-- maybe no need to implemention, because rename is a simple operation

local M = {}

-- get all valid clients of rename
--- @param buffer_id integer
--- @return vim.lsp.Client[]? clients array or nil
M.get_clients = function(buffer_id)
    -- note: we need get lsp clients attached to current buffer
    local clients = lsp.get_clients({
        bufnr = buffer_id,
        method = rename_feature,
    })
    if vim.tbl_isempty(clients) then
        return nil
    end
    return clients
end

-- rename
--- @param client vim.lsp.Client lsp client instance, must be element of func `get_clients`
--- @param buffer_id integer buffer id
--- @param position_param lsp.RenameParams  this param must be generated by `vim.lsp.util.make_position_params`, has newname attribute
--- @param callback function
local function rename(client, buffer_id, position_param, callback)
    local handler = client.handlers[rename_feature]
        or lsp.handlers[rename_feature]
    vim.schedule(function()
        client.request(rename_feature, position_param, function(...)
            handler(...)
            callback()
        end, buffer_id)
    end)
end

-- prepare rename, whether we can execute rename
-- if request return eroor, that mean we can't rename, and we should skip this
--- @param client vim.lsp.Client lsp client instance, must be element of func `get_clients`
--- @param buffer_id integer buffer id
--- @param position_param lsp.PrepareRenameParams  this param must be generated by `vim.lsp.util.make_position_params`
--- @param callback fun(result:LspUI_prepare_rename_res?)
local function prepare_rename(client, buffer_id, position_param, callback)
    local function __tmp()
        client.request(
            prepare_rename_feature,
            position_param,
            --- @type lsp.Handler
            --- @diagnostic disable-next-line: unused-local
            function(err, result, ctx, _)
                if err then
                    lib_notify.Error(
                        "error code:" .. err.code .. ", " .. err.message
                    )
                    return
                end
                --- @type LspUI_prepare_rename_res
                local res = result
                if result == nil then
                    callback()
                    return
                end
                callback(res)
            end,
            buffer_id
        )
    end
    vim.schedule(__tmp)
end

--- @param id integer
--- @param clients vim.lsp.Client[] lsp client instance, must be element of func `get_clients`
--- @param buffer_id integer buffer id
--- @param position_param lsp.PrepareRenameParams|lsp.RenameParams this param must be generated by `vim.lsp.util.make_position_params`, has newname attribute
--- @param callback fun(clients: vim.lsp.Client[])
--- @param final_clients vim.lsp.Client[]
local function if_rename(
    id,
    clients,
    buffer_id,
    position_param,
    callback,
    final_clients
)
    --- @param __final_clients vim.lsp.Client[]
    local function __next_rename(__final_clients)
        local next_id, _ = next(clients, id)
        if_rename(
            next_id,
            clients,
            buffer_id,
            position_param,
            callback,
            __final_clients
        )
    end

    if not id then
        callback(final_clients)
        return
    end

    local client = clients[id]

    if client.supports_method(prepare_rename_feature) then
        prepare_rename(
            client,
            buffer_id,
            --- @cast position_param lsp.PrepareRenameParams
            position_param,
            -- we no need to resuse the result, we just use it todetect whether we can do rename
            function(result)
                if result then
                    table.insert(final_clients, client)
                end
                __next_rename(final_clients)
            end
        )
        return
    end
    table.insert(final_clients, client)
    __next_rename(final_clients)
end

-- do rename, a wrap function for prepare_rename and rename
--- @param id integer
--- @param clients vim.lsp.Client[] lsp client instance, must be element of func `get_clients`
--- @param buffer_id integer buffer id
--- @param position_param lsp.PrepareRenameParams|lsp.RenameParams this param must be generated by `vim.lsp.util.make_position_params`, has newname attribute
local function do_rename(id, clients, buffer_id, position_param)
    local function next_rename()
        local next_id, _ = next(clients, id)
        do_rename(next_id, clients, buffer_id, position_param)
    end

    local async = uv.new_async(function()
        if not id then
            return
        end

        local client = clients[id]
        --- @cast position_param lsp.RenameParams
        rename(client, buffer_id, position_param, next_rename)
    end)

    if async then
        async:send()
    else
        lib_notify.Error("async wrap doreaname failed")
    end
end

-- wrap windows.close_window
-- add detect insert mode
--- @param window_id integer
local close_window = function(window_id)
    if vim.fn.mode() == "i" then
        vim.cmd([[stopinsert]])
    end
    lib_windows.close_window(window_id)
end

-- calculate display length
--- @param str string
local function calculate_length(str)
    local len = fn.strdisplaywidth(str) + 2
    return len > 10 and len or 10
end

-- keybinding and autocommand
--- @param window_id integer rename float window's id
--- @param old_name string the word's old name
--- @param clients vim.lsp.Client[] lsp clients
--- @param old_buffer integer the buffer which word belongs to
--- @param new_buffer integer the buffer which attach to rename float window
--- @param position_param lsp.PrepareRenameParams|lsp.RenameParams this param must be generated by `vim.lsp.util.make_position_params`
local function keybinding_autocmd(
    window_id,
    old_name,
    clients,
    old_buffer,
    new_buffer,
    position_param
)
    -- keybinding exec
    for _, mode in pairs({ "i", "n", "v" }) do
        api.nvim_buf_set_keymap(
            new_buffer,
            mode,
            config.options.rename.key_binding.exec,
            "",
            {
                nowait = true,
                noremap = true,
                callback = function()
                    local new_name = vim.trim(api.nvim_get_current_line())
                    if old_name ~= new_name then
                        position_param.newName = new_name
                        do_rename(1, clients, old_buffer, position_param)
                    end
                    close_window(window_id)
                end,
                desc = lib_util.command_desc("exec rename"),
            }
        )
    end

    -- keybinding quit
    api.nvim_buf_set_keymap(
        new_buffer,
        "n",
        config.options.rename.key_binding.quit,
        "",
        {
            nowait = true,
            noremap = true,
            callback = function()
                close_window(window_id)
            end,
            desc = lib_util.command_desc("quit rename"),
        }
    )

    local autocmd_group_id =
        vim.api.nvim_create_augroup("LspUI-rename_autocmd_group", {
            clear = true,
        })

    api.nvim_create_autocmd({ "TextChanged", "TextChangedI" }, {
        group = autocmd_group_id,
        buffer = new_buffer,
        callback = function()
            local now_name = api.nvim_get_current_line()
            local len = calculate_length(now_name)
            api.nvim_win_set_config(window_id, {
                width = len,
            })
        end,
        desc = lib_util.command_desc(
            "automatically lengthen the rename input box"
        ),
    })

    -- auto command: auto close window, when focus leave rename float window
    api.nvim_create_autocmd("WinLeave", {
        group = autocmd_group_id,
        buffer = new_buffer,
        once = true,
        callback = function()
            close_window(window_id)
        end,
        desc = lib_util.command_desc(
            "rename auto close windows when focus leave"
        ),
    })
end

-- render the window
--- @param clients vim.lsp.Client[]
--- @param buffer_id integer
--- @param old_name string
--- @param position_param lsp.PrepareRenameParams|lsp.RenameParams this param must be generated by `vim.lsp.util.make_position_params`
local function render(clients, buffer_id, old_name, position_param)
    local new_buffer = api.nvim_create_buf(false, true)

    -- note: this must set before modifiable, when modifiable is false, this function will fail
    api.nvim_buf_set_lines(new_buffer, 0, -1, false, {
        --- @cast old_name string
        old_name,
    })

    -- this will remove the undo history
    vim.api.nvim_buf_call(new_buffer, function()
        local old_undolevels = vim.bo.undolevels
        vim.bo.undolevels = -1
        vim.cmd("normal! a \b") -- Make a meaningless change and then delete it.
        vim.bo.undolevels = old_undolevels
    end)

    api.nvim_set_option_value("filetype", "LspUI-rename", { buf = new_buffer })
    api.nvim_set_option_value("modifiable", true, { buf = new_buffer })
    api.nvim_set_option_value("bufhidden", "wipe", { buf = new_buffer })

    local new_window_wrap = lib_windows.new_window(new_buffer)

    -- For aesthetics, the minimum width is 8
    local width = calculate_length(old_name)

    lib_windows.set_width_window(new_window_wrap, width)
    lib_windows.set_height_window(new_window_wrap, 1)
    lib_windows.set_enter_window(new_window_wrap, true)
    lib_windows.set_anchor_window(new_window_wrap, "NW")
    lib_windows.set_border_window(new_window_wrap, "rounded")
    lib_windows.set_focusable_window(new_window_wrap, true)
    lib_windows.set_relative_window(new_window_wrap, "cursor")
    lib_windows.set_col_window(new_window_wrap, 1)
    lib_windows.set_row_window(new_window_wrap, 1)
    lib_windows.set_style_window(new_window_wrap, "minimal")
    lib_windows.set_right_title_window(new_window_wrap, "rename")

    local window_id = lib_windows.display_window(new_window_wrap)

    api.nvim_set_option_value("winhighlight", "Normal:Normal", {
        win = window_id,
    })
    api.nvim_set_option_value("winblend", config.options.rename.transparency, {
        win = window_id,
    })

    if config.options.rename.auto_select then
        api.nvim_win_call(window_id, function()
            vim.cmd([[normal! V]])
            api.nvim_feedkeys(
                api.nvim_replace_termcodes("<C-g>", true, true, true),
                "n",
                false
            )
        end)
    end

    -- keybinding and autocommand
    keybinding_autocmd(
        window_id,
        old_name,
        clients,
        buffer_id,
        new_buffer,
        position_param
    )
end

-- render the window
--- @param clients vim.lsp.Client[]
--- @param buffer_id integer
--- @param current_win integer
--- @param old_name string
M.done = function(clients, buffer_id, current_win, old_name)
    local position_param = lsp.util.make_position_params(current_win)
    if_rename(1, clients, buffer_id, position_param, function(__clients)
        if #__clients < 1 then
            lib_notify.Info("This position can not rename!")
            return
        end
        render(__clients, buffer_id, old_name, position_param)
    end, {})
end

return M
