local lsp, api, fn, uv = vim.lsp, vim.api, vim.fn, vim.uv
local rename_feature = lsp.protocol.Methods.textDocument_rename
local prepare_rename_feature = lsp.protocol.Methods.textDocument_prepareRename

local config = require("LspUI.config")
local layer = require("LspUI.layer")
local lib_notify = require("LspUI.lib.notify")

--- @alias LspUI_prepare_rename_res lsp.Range | { range: lsp.Range, placeholder: string } | { defaultBehavior: boolean } | nil

-- TODO: add progress support !!
-- maybe no need to implemention, because rename is a simple operation

local M = {}

-- get all valid clients of rename
--- @param buffer_id integer
--- @return vim.lsp.Client[]? clients array or nil
M.get_clients = function(buffer_id)
    -- note: we need get lsp clients attached to current buffer
    local clients = lsp.get_clients({
        bufnr = buffer_id,
        method = rename_feature,
    })
    if vim.tbl_isempty(clients) then
        return nil
    end
    return clients
end

-- rename
--- @param client vim.lsp.Client lsp client instance, must be element of func `get_clients`
--- @param buffer_id integer buffer id
--- @param position_param lsp.RenameParams  this param must be generated by `vim.lsp.util.make_position_params`, has newname attribute
--- @param callback function
local function rename(client, buffer_id, position_param, callback)
    local handler = client.handlers[rename_feature]
        or lsp.handlers[rename_feature]
    vim.schedule(function()
        client:request(rename_feature, position_param, function(...)
            handler(...)
            callback()
        end, buffer_id)
    end)
end

-- prepare rename, whether we can execute rename
-- if request return eroor, that mean we can't rename, and we should skip this
--- @param client vim.lsp.Client lsp client instance, must be element of func `get_clients`
--- @param buffer_id integer buffer id
--- @param position_param lsp.PrepareRenameParams  this param must be generated by `vim.lsp.util.make_position_params`
--- @param callback fun(result:LspUI_prepare_rename_res?)
local function prepare_rename(client, buffer_id, position_param, callback)
    local function __tmp()
        client:request(
            prepare_rename_feature,
            position_param,
            --- @type lsp.Handler
            --- @diagnostic disable-next-line: unused-local
            function(err, result, ctx, _)
                if err then
                    lib_notify.Error(
                        "error code:" .. err.code .. ", " .. err.message
                    )
                    return
                end
                --- @type LspUI_prepare_rename_res
                local res = result
                if result == nil then
                    callback()
                    return
                end
                callback(res)
            end,
            buffer_id
        )
    end
    vim.schedule(__tmp)
end

--- @param id integer|nil
--- @param clients vim.lsp.Client[] lsp client instance, must be element of func `get_clients`
--- @param buffer_id integer buffer id
--- @param position_param lsp.PrepareRenameParams|lsp.RenameParams this param must be generated by `vim.lsp.util.make_position_params`, has newname attribute
--- @param callback fun(clients: vim.lsp.Client[])
--- @param final_clients vim.lsp.Client[]
local function if_rename(
    id,
    clients,
    buffer_id,
    position_param,
    callback,
    final_clients
)
    --- @param __final_clients vim.lsp.Client[]
    local function __next_rename(__final_clients)
        local next_id, _ = next(clients, id)
        if_rename(
            next_id,
            clients,
            buffer_id,
            position_param,
            callback,
            __final_clients
        )
    end

    if not id then
        callback(final_clients)
        return
    end

    local client = clients[id]

    if client:supports_method(prepare_rename_feature) then
        prepare_rename(
            client,
            buffer_id,
            --- @cast position_param lsp.PrepareRenameParams
            position_param,
            -- we no need to resuse the result, we just use it todetect whether we can do rename
            function(result)
                if result then
                    table.insert(final_clients, client)
                end
                __next_rename(final_clients)
            end
        )
        return
    end
    table.insert(final_clients, client)
    __next_rename(final_clients)
end

-- do rename, a wrap function for prepare_rename and rename
--- @param id integer|nil
--- @param clients vim.lsp.Client[] lsp client instance, must be element of func `get_clients`
--- @param buffer_id integer buffer id
--- @param position_param lsp.PrepareRenameParams|lsp.RenameParams this param must be generated by `vim.lsp.util.make_position_params`, has newname attribute
local function do_rename(id, clients, buffer_id, position_param)
    local function next_rename()
        local next_id, _ = next(clients, id)
        do_rename(next_id, clients, buffer_id, position_param)
    end

    local async = uv.new_async(function()
        if not id then
            return
        end

        local client = clients[id]
        --- @cast position_param lsp.RenameParams
        rename(client, buffer_id, position_param, next_rename)
    end)

    if async then
        async:send()
    else
        lib_notify.Error("async wrap doreaname failed")
    end
end

-- calculate display length
--- @param str string
local function calculate_length(str)
    local len = fn.strdisplaywidth(str) + 2
    return len > 10 and len or 10
end

-- keybinding and autocommand
--- @param view ClassView rename float window's id
--- @param old_name string the word's old name
--- @param clients vim.lsp.Client[] lsp clients
--- @param old_buffer integer the buffer which word belongs to
--- @param position_param lsp.PrepareRenameParams|lsp.RenameParams this param must be generated by `vim.lsp.util.make_position_params`
local function keybinding_autocmd(
    view,
    old_name,
    clients,
    old_buffer,
    position_param
)
    -- keybinding exec
    for _, mode in pairs({ "i", "n", "v" }) do
        local function cb()
            local new_name = vim.trim(api.nvim_get_current_line())
            if old_name ~= new_name then
                position_param.newName = new_name
                do_rename(1, clients, old_buffer, position_param)
            end
            view:Destroy()
        end
        local key = config.options.rename.key_binding.exec
        ---@diagnostic disable-next-line: param-type-mismatch
        view:KeyMap(mode, key, cb, "exec rename")
    end

    view:KeyMap("n", config.options.rename.key_binding.quit, function()
        view:Destroy()
    end, "quit rename")

    local autocmd_group_id =
        vim.api.nvim_create_augroup("LspUI-rename_autocmd_group", {
            clear = true,
        })

    view:BufAutoCmd(
        { "TextChanged", "TextChangedI" },
        autocmd_group_id,
        function()
            local now_name = api.nvim_get_current_line()
            local len = calculate_length(now_name)
            ---@diagnostic disable-next-line: param-type-mismatch
            api.nvim_win_set_config(view:GetWinID(), {
                width = len,
            })
        end,
        "automatically lengthen the rename input box"
    )

    view:BufAutoCmd("WinLeave", autocmd_group_id, function()
        view:Destroy()
    end, "rename auto close windows when focus leave")
end

-- render the window
--- @param clients vim.lsp.Client[]
--- @param buffer_id integer
--- @param old_name string
--- @param position_param lsp.PrepareRenameParams|lsp.RenameParams this param must be generated by `vim.lsp.util.make_position_params`
local function render(clients, buffer_id, old_name, position_param)
    local width = calculate_length(old_name)

    local view = layer.ClassView
        :New(true)
        :BufContent(0, -1, { old_name })
        :BufCall(function()
            -- 执行一段无意义的操作，以便撤销时不会撤销到原来的内容
            local old_undolevels = vim.bo.undolevels
            vim.bo.undolevels = -1
            vim.cmd("normal! a \b") -- Make a meaningless change and then delete it.
            vim.bo.undolevels = old_undolevels
        end)
        :BufOption("filetype", "LspUI-rename")
        :BufOption("modifiable", true)
        :BufOption("bufhidden", "wipe")
        :Size(width, 1)
        :Enter(true)
        :Anchor("NW")
        :Border("rounded")
        :Focusable(true)
        :Relative("cursor")
        :Pos(1, 1)
        :Style("minimal")
        :Title("rename", "right")
        :Render()
        :Winhl("Normal:Normal")
        :Winbl(config.options.rename.transparency)
        :Call(function()
            if config.options.rename.auto_select then
                vim.cmd([[normal! V]])
                api.nvim_feedkeys(
                    api.nvim_replace_termcodes("<C-g>", true, true, true),
                    "n",
                    false
                )
            end
        end)

    -- keybinding and autocommand
    keybinding_autocmd(view, old_name, clients, buffer_id, position_param)
end

-- render the window
--- @param clients vim.lsp.Client[]
--- @param buffer_id integer
--- @param current_win integer
--- @param old_name string
function M.done(clients, buffer_id, current_win, old_name)
    local position_param =
        lsp.util.make_position_params(current_win, clients[1].offset_encoding)
    ---@diagnostic disable-next-line: param-type-mismatch
    if_rename(1, clients, buffer_id, position_param, function(__clients)
        if #__clients < 1 then
            lib_notify.Info("This position can not rename!")
            return
        end
        ---@diagnostic disable-next-line: param-type-mismatch
        render(__clients, buffer_id, old_name, position_param)
    end, {})
end

return M
